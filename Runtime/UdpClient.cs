/*===========================================================
    Author: Ruan Cardoso
    -
    Country: Brazil(Brasil)
    -
    Contact: cardoso.ruan050322@gmail.com
    -
    Support: neutron050322@gmail.com
    -
    Unity Minor Version: 2021.3 LTS
    -
    License: Open Source (MIT)
    ===========================================================*/

using System;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using static Omni.Core.Enums;
using static Omni.Core.OmniNetwork;

namespace Omni.Core
{
	internal sealed class UdpClient : UdpSocket
	{
		public OmniPlayer Player { get; }
		internal int Id { get; private set; }

		/// <summary>
		/// Gets or sets the AES key used for encryption.
		/// This key is generated by the server and sent to the client when the connection is established.
		/// The RSA Algorithm is used to exchange the AES key.
		/// </summary>
		internal byte[] AESPublicKey { get; set; }
		internal byte[] AESPrivateKey { get; set; }
		internal string RSAPublicKey { get; set; }
		internal string RSAPrivateKey { get; set; }

		protected override string Name => "Omni_Client";
		protected override bool IsServer => false;

		internal bool RSAKeysExchanged = false;
		internal double lastTimeReceivedPing;
		internal bool itSelf;
		internal UdpEndPoint remoteEndPoint;
		internal UdpClient(bool itSelf = false)
		{
			this.itSelf = itSelf;
			if (this.itSelf)
			{
				Id = NetworkId;
				remoteEndPoint = new UdpEndPoint(IPAddress.Loopback, Port);
				Player = new(Id, remoteEndPoint);
			}
			else { /*Client Player*/ }
		}

		internal UdpClient(UdpEndPoint remoteEndPoint, Socket socket) // [SERVER CONSTRUCTOR]
		{
			Initialize();
			IsConnected = true;
			base.socket = socket;
			lastTimeReceivedPing = OmniTime.LocalTime;
			Id = remoteEndPoint.GetPort();
			Player = new(Id, remoteEndPoint);
			this.remoteEndPoint = new(remoteEndPoint.GetIPAddress(), Id); // copy endpoint to avoid reference problems!
			WINDOW(this.remoteEndPoint);
		}

		internal void Connect(UdpEndPoint remoteEndPoint, CancellationToken cancellationToken)
		{
			this.remoteEndPoint = remoteEndPoint;
			WINDOW(this.remoteEndPoint);
			Instance.StartCoroutine(RSAExchange());
			Instance.StartCoroutine(Connect());

			// Check if the host is available
			Task.Run(async () =>
			{
				await Task.Delay(10000, cancellationToken);
				if (!IsConnected)
				{
					Instance.StopCoroutine(Connect());
					OmniLogger.LogError($"Sorry, it seems that the host is currently unavailable. Please try again later -> {remoteEndPoint}");
				}
			}, cancellationToken);
		}

		internal void Disconnect()
		{
			DataIOHandler IOHandler = DataIOHandler.Get(MessageType.Disconnect, true);
			//Send(IOHandler, DataDeliveryMode.Secured, DataTarget.Self);
			IOHandler.Release();
			OnDisconnected();
		}

		internal void OnDisconnected()
		{
			Instance.StopCoroutine(RSAExchange());
			Instance.StopCoroutine(Connect());
			Instance.StopCoroutine(Ping());

			IsConnected = false;
			remoteEndPoint = null;
		}

		WaitForSeconds RSAInterval = new(1);
		private IEnumerator RSAExchange()
		{
			while (!IsConnected)
			{
				if (RSAKeysGenerated)
				{
					DataIOHandler IOHandler = DataIOHandler.Get(MessageType.RSAExchange);
					IOHandler.Write(RSAPublicKey);
					Send(IOHandler, DataDeliveryMode.Unsecured, DataTarget.Self);
					IOHandler.Release();
				}

				yield return RSAInterval;
			}
		}

		private IEnumerator Connect()
		{
			if (IsConnected)
			{
				OmniLogger.PrintError("You are connected!");
			}

			while (!IsConnected)
			{
				if (RSAKeysExchanged)
				{
					DataIOHandler IOHandler = DataIOHandler.Get(MessageType.Connect);
					IOHandler.Write128Bits(AESPublicKey);
					Send(IOHandler, DataDeliveryMode.Unsecured, DataTarget.Self);
					IOHandler.Release();
					yield return WAIT_FOR_CONNECT;
					if (!IsConnected)
					{
						OmniLogger.Log("Retrying to establish connection...");
					}
				}

				// Avoid blocking the main thread
				yield return null;
			}
		}

		private IEnumerator Ping()
		{
			while (IsConnected)
			{
				DataIOHandler IOHandler = DataIOHandler.Get();
				IOHandler.WritePacket(MessageType.Ping);
				IOHandler.Write(OmniTime.LocalTime);
				Send(IOHandler, DataDeliveryMode.Unsecured, DataTarget.Self);
				IOHandler.Release();
				yield return WAIT_FOR_PING;
			}
		}

		ulong msgSent, msgRec;
		WaitForSeconds measuringInterval = new(10);
		private IEnumerator MeasurePacketLoss()
		{
			int qtde = 10;
			while (IsConnected)
			{
				for (int i = 0; i < qtde; i++)
				{
					msgSent++;
					DataIOHandler IOHandler = DataIOHandler.Get(MessageType.PacketLoss, true);
					Send(IOHandler, DataDeliveryMode.Unsecured, DataTarget.Self);
					IOHandler.Release();
				}

				yield return measuringInterval;
				NetworkMonitor.PacketsLost = (msgSent - msgRec) * 10;
				msgSent = msgRec = 0;
			}
		}

		/// <summary>
		/// Sends data using RAW mode; this mode does not write the payload.<br/>
		/// Data is sent directly through the socket, without going through additional steps before transmission.<br/>
		/// Used to send data that has already been assembled, ex: Retransmission messages.
		/// </summary>
		internal int Send(DataIOHandler IOHandler) => Send(IOHandler, remoteEndPoint, 0);
		/// <summary>
		/// Sends data using the payload mode.<br/>
		/// Data is sent through the socket, but before that, it goes through additional steps before transmission.<br/>
		/// Used to send data that has not yet been assembled, ex: Data messages.
		/// </summary>
		internal int Send(DataIOHandler IOHandler, DataDeliveryMode deliveryMode = DataDeliveryMode.Unsecured, DataTarget target = DataTarget.Self, DataProcessingOption processingOption = DataProcessingOption.DoNotProcessOnServer, DataCachingOption cachingOption = DataCachingOption.None)
		{
			if (remoteEndPoint == null)
			{
				OmniLogger.PrintError("Error: Call Connect() before Send()");
				return 0;
			}

			return IOSend(IOHandler, remoteEndPoint, deliveryMode, target, processingOption, cachingOption);
		}

		protected override void OnMessage(DataIOHandler IOHandler, DataDeliveryMode deliveryMode, DataTarget target, DataProcessingOption processingOption, DataCachingOption cachingOption, MessageType messageType, UdpEndPoint remoteEndPoint)
		{
			switch (messageType)
			{
				case MessageType.Connect:
					{
						if (!IsConnected)
						{
							Id = IOHandler.ReadUShort();
							AESPrivateKey = IOHandler.Read128Bits();
							IsConnected = true;
							Instance.StartCoroutine(Ping());
							Instance.StartCoroutine(MeasurePacketLoss());

							// Reposiciona o IOHandler para a posi��o 0
							// Chama o evento OnMessage do OmniNetwork com os par�metros fornecidos
							IOHandler.Position = 0;
							OmniNetwork.OnMessage(IOHandler, messageType, deliveryMode, target, processingOption, cachingOption, remoteEndPoint, IsServer);
						}
						else
						{
							OmniLogger.PrintError("Error: The client is already connected. Disconnect before attempting to connect again.");
						}
					}
					break;
				case MessageType.Ping:
					{
						double timeOfClient = IOHandler.ReadDouble();
						double timeOfServer = IOHandler.ReadDouble();
						OmniTime.SetTime(timeOfClient, timeOfServer);

						// Reposiciona o IOHandler para a posi��o 0
						// Chama o evento OnMessage do OmniNetwork com os par�metros fornecidos
						IOHandler.Position = 0;
						OmniNetwork.OnMessage(IOHandler, messageType, deliveryMode, target, processingOption, cachingOption, remoteEndPoint, IsServer);
					}
					break;
				case MessageType.PacketLoss:
					msgRec++;
					break;
				default:
					OmniNetwork.OnMessage(IOHandler, messageType, deliveryMode, target, processingOption, cachingOption, remoteEndPoint, IsServer);
					break;
			}
		}

		internal UdpClient GetClient(ushort playerId) => throw new NotImplementedException("GetClient method is not implemented.");
		internal override UdpClient GetClient(UdpEndPoint remoteEndPoint) => this;
		protected override void Disconnect(UdpEndPoint endPoint, string msg = "") => OnDisconnected();
	}
}