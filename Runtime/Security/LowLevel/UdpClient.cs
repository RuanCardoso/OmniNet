/*===========================================================
    Author: Ruan Cardoso
    -
    Country: Brazil(Brasil)
    -
    Contact: cardoso.ruan050322@gmail.com
    -
    Support: neutron050322@gmail.com
    -
    Unity Minor Version: 2021.3 LTS
    -
    License: Open Source (MIT)
    ===========================================================*/

using Omni.Core.Cryptography;
using System;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.Threading.Tasks;
using UnityEngine;
using static Omni.Core.Enums;
using static Omni.Core.OmniNetwork;

namespace Omni.Core
{
	//internal sealed class UdpClient : OmniTransporter
	//{
	//	public OmniPlayer Player { get; }
	//	internal int Id { get; private set; }

	//	protected override bool IsServer => false;

	//	/// <summary>
	//	///  Stores the RSA keys used for encryption and decryption purposes.
	//	///  The public key (RSAPublicKey) is employed to encrypt data, ensuring that it can only be
	//	///  decrypted later using the corresponding private key (RSAPrivateKey).
	//	/// </summary>
	//	internal string RsaPublicKey;
	//	/// <summary>
	//	///  Stores the private RSA key used for decrypting data that has been encrypted with the
	//	///  associated public key. This key is crucial for the secure retrieval of original information.
	//	/// </summary>
	//	internal string RsaPrivateKey;
	//	/// <summary>
	//	/// Gets or sets the AES key used for encryption.
	//	/// This key is generated by the server and sent to the client when the connection is established.
	//	/// The RSA Algorithm is used to exchange the AES key.
	//	/// </summary>
	//	internal byte[] AesPublicKey { get; set; }
	//	internal byte[] AesPrivateKey { get; set; }

	//	internal double lastTimeReceivedPing;
	//	internal bool isServer;
	//	internal UdpEndPoint remoteEndPoint;
	//	internal UdpClient(bool isServer = false)
	//	{
	//		this.isServer = isServer;
	//		if (this.isServer) // Server is client too!
	//		{
	//			Id = NetworkId;
	//			remoteEndPoint = new UdpEndPoint(IPAddress.Loopback, Port);
	//			Player = new(Id, remoteEndPoint);
	//		}
	//		else // Local Client
	//		{
	//			OnBind += UdpClient_OnBind;
	//		}
	//	}

	//	internal UdpClient(UdpEndPoint remoteEndPoint, Socket socket) // [SERVER CONSTRUCTOR] - Remote Client
	//	{
	//		Initialize();
	//		IsConnected = true;
	//		base.socket = socket;
	//		lastTimeReceivedPing = OmniTime.LocalTime;
	//		Id = remoteEndPoint.GetPort();
	//		Player = new(Id, remoteEndPoint);
	//		this.remoteEndPoint = new(remoteEndPoint.GetIPAddress(), Id); // copy endpoint to avoid reference problems!
	//		Window(this.remoteEndPoint);
	//	}

	//	private void UdpClient_OnBind()
	//	{
	//		InternalEventHandler.OnTcpDataReceived += InternalEventHandler_OnTcpDataReceived;
	//		InternalEventHandler.OnTcpConnected += InternalEventHandler_OnTcpConnected;
	//	}

	//	private async void InternalEventHandler_OnTcpConnected()
	//	{
	//		await GenerateAuthKeysAsync();
	//		DataIOHandler IOHandler = new(RSACryptography.IOHandlerSize);
	//		IOHandler.WritePacket(MessageType.RSAExchange);
	//		IOHandler.Write(RsaPublicKey);
	//		tcpClient.SendToServer(IOHandler);
	//	}

	//	internal Task GenerateAuthKeysAsync()
	//	{
	//		return Task.Run(() =>
	//		{
	//			RSACryptography.GetRSAKeys(out RsaPrivateKey, out RsaPublicKey);
	//			// 1. **Data Confidentiality:**
	//			//    - The use of unique AES keys ensures that information transmitted between the client and the server remains confidential, as it is uniquely encrypted for each connection.

	//			// 2. **Unique Keys:**
	//			//    - Each client is assigned a unique AES key upon connection, preventing attackers from using a compromised key on one client to access data from others. This limits the impact of potential security breaches.

	//			// 3. **Avoids Key Reuse:**
	//			//    - Generating new keys for each connection eliminates key reuse, enhancing security by avoiding potential vulnerabilities associated with the practice of using the same key repeatedly.
	//			//    - RSA keys are used to exchange AES keys between the client and the server, ensuring that the AES keys are securely transmitted.
	//			AesPublicKey = Aes.GenerateKey();
	//		}, cancellationTokenSource.Token);
	//	}

	//	internal void Initialize(UdpEndPoint remoteEndPoint)
	//	{
	//		this.remoteEndPoint = remoteEndPoint;
	//		Window(this.remoteEndPoint);
	//	}

	//	internal void Disconnect()
	//	{
	//		DataIOHandler IOHandler = DataIOHandler.Get(MessageType.Disconnect, true);
	//		//Send(IOHandler, DataDeliveryMode.Secured, DataTarget.Self);
	//		IOHandler.Release();
	//		OnDisconnected();
	//	}

	//	internal void OnDisconnected()
	//	{
	//		Instance.StopCoroutine(Ping());
	//		IsConnected = false;
	//		remoteEndPoint = null;
	//	}

	//	private new void Connect()
	//	{
	//		if (IsConnected)
	//		{
	//			OmniLogger.PrintError("You are connected!");
	//		}

	//		DataIOHandler IOHandler = new(RSACryptography.IOHandlerSize);
	//		IOHandler.WritePacket(MessageType.AESExchange);
	//		IOHandler.WriteNBits(RSACryptography.Encrypt(AesPublicKey, RsaPublicKey));
	//		tcpClient.SendToServer(IOHandler);
	//	}

	//	private IEnumerator Ping()
	//	{
	//		while (IsConnected)
	//		{
	//			DataIOHandler IOHandler = DataIOHandler.Get();
	//			IOHandler.WritePacket(MessageType.Ping);
	//			IOHandler.Write(OmniTime.LocalTime);
	//			Send(IOHandler, DataDeliveryMode.Unsecured, DataTarget.Self);
	//			IOHandler.Release();
	//			yield return WAIT_FOR_PING;
	//		}
	//	}

	//	ulong msgSent, msgRec;
	//	WaitForSeconds measuringInterval = new(10);
	//	private IEnumerator MeasurePacketLoss()
	//	{
	//		int qtde = 10;
	//		while (IsConnected)
	//		{
	//			for (int i = 0; i < qtde; i++)
	//			{
	//				msgSent++;
	//				DataIOHandler IOHandler = DataIOHandler.Get(MessageType.PacketLoss, true);
	//				Send(IOHandler, DataDeliveryMode.Unsecured, DataTarget.Self);
	//				IOHandler.Release();
	//			}

	//			yield return measuringInterval;
	//			NetworkMonitor.PacketsLost = (msgSent - msgRec) * 10;
	//			msgSent = msgRec = 0;
	//		}
	//	}

	//	private void InternalEventHandler_OnTcpDataReceived(DataIOHandler IOHandler, UdpEndPoint remoteEndPoint, bool isServer, DataTarget dataTarget, DataProcessingOption dataProcessingOption, DataCachingOption dataCachingOption)
	//	{
	//		if (!isServer)
	//		{
	//			MessageType messageType = IOHandler.ReadPacket();
	//			switch (messageType)
	//			{
	//				case MessageType.RSAExchange:
	//					RsaPublicKey = IOHandler.ReadString();
	//					Connect();
	//					break;
	//				case MessageType.AESExchange:
	//					if (!IsConnected)
	//					{
	//						Id = IOHandler.ReadUShort();
	//						AesPrivateKey = RSACryptography.Decrypt(IOHandler.ReadNBits(), RsaPrivateKey);
	//						IsConnected = true;
	//						Instance.StartCoroutine(Ping());
	//						Instance.StartCoroutine(MeasurePacketLoss());

	//						// Reposiciona o IOHandler para a posi��o 0
	//						// Chama o evento OnMessage do OmniNetwork com os par�metros fornecidos
	//						IOHandler.FixedPosition = 0;
	//						OmniNetwork.OnMessage(IOHandler, messageType, DataDeliveryMode.Secured, dataTarget, dataProcessingOption, dataCachingOption, remoteEndPoint, isServer);
	//					}
	//					else
	//					{
	//						OmniLogger.PrintError("Error: The client is already connected. Disconnect before attempting to connect again.");
	//					}
	//					break;
	//			}
	//		}
	//	}

	//	/// <summary>
	//	/// Sends data using RAW mode; this mode does not write the payload.<br/>
	//	/// Data is sent directly through the socket, without going through additional steps before transmission.<br/>
	//	/// Used to send data that has already been assembled, ex: Retransmission messages.
	//	/// </summary>
	//	internal int Send(DataIOHandler IOHandler) => Send(IOHandler, remoteEndPoint, 0);
	//	/// <summary>
	//	/// Sends data using the payload mode.<br/>
	//	/// Data is sent through the socket, but before that, it goes through additional steps before transmission.<br/>
	//	/// Used to send data that has not yet been assembled, ex: Data messages.
	//	/// </summary>
	//	internal int Send(DataIOHandler IOHandler, DataDeliveryMode deliveryMode = DataDeliveryMode.Unsecured, DataTarget target = DataTarget.Self, DataProcessingOption processingOption = DataProcessingOption.DoNotProcessOnServer, DataCachingOption cachingOption = DataCachingOption.None)
	//	{
	//		if (remoteEndPoint == null)
	//		{
	//			OmniLogger.PrintError("Error: Call Connect() before Send()");
	//			return 0;
	//		}

	//		return IOSend(IOHandler, remoteEndPoint, deliveryMode, target, processingOption, cachingOption);
	//	}

	//	protected override void OnMessage(DataIOHandler IOHandler, DataDeliveryMode deliveryMode, DataTarget target, DataProcessingOption processingOption, DataCachingOption cachingOption, MessageType messageType, UdpEndPoint remoteEndPoint)
	//	{
	//		switch (messageType)
	//		{
	//			case MessageType.Ping:
	//				{
	//					double timeOfClient = IOHandler.ReadDouble();
	//					double timeOfServer = IOHandler.ReadDouble();
	//					OmniTime.SetTime(timeOfClient, timeOfServer);

	//					// Reposiciona o IOHandler para a posi��o 0
	//					// Chama o evento OnMessage do OmniNetwork com os par�metros fornecidos
	//					IOHandler.FixedPosition = 0;
	//					OmniNetwork.OnMessage(IOHandler, messageType, deliveryMode, target, processingOption, cachingOption, remoteEndPoint, IsServer);
	//				}
	//				break;
	//			case MessageType.PacketLoss:
	//				msgRec++;
	//				break;
	//			default:
	//				OmniNetwork.OnMessage(IOHandler, messageType, deliveryMode, target, processingOption, cachingOption, remoteEndPoint, IsServer);
	//				break;
	//		}
	//	}

	//	internal UdpClient GetClient(ushort playerId) => throw new NotImplementedException("GetClient method is not implemented.");
	//	protected override UdpClient GetClient(UdpEndPoint remoteEndPoint) => this;
	//	protected override void Disconnect(UdpEndPoint endPoint, string msg = "") => OnDisconnected();
	//}
}